{"meta":{"title":"领江的小博客","subtitle":"记录在学校挣扎的苦逼生活...","description":null,"author":"Dany Xie","url":"http://sowhatxie.top"},"pages":[{"title":"我呀。。","date":"2017-07-12T12:29:13.000Z","updated":"2017-07-12T12:31:28.177Z","comments":true,"path":"about/index.html","permalink":"http://sowhatxie.top/about/index.html","excerpt":"","text":"挣扎中，欢迎小姐姐来拯救我哦！"}],"posts":[{"title":"markdown测试2","slug":"测试 最大标题","date":"2017-05-14T07:17:10.000Z","updated":"2017-07-14T12:46:31.809Z","comments":true,"path":"2017/05/14/测试 最大标题/","link":"","permalink":"http://sowhatxie.top/2017/05/14/测试 最大标题/","excerpt":"","text":"测试 最大标题段落标题 1下面是一个无序列表（无缩进） 换行两个以上空格再加回车 1 第一行 3 第二行 4 第三行 5 第四行 下面又是一个无序列表（本行无缩进） 1 第一行 2 第二行 3 第三行 段落标题 2直接两个空格（没有缩进） &emsp;&emsp;这里直接利用写两个全角空格代码缩进 下面是有序列表 第一行 第二行 第三行 &emsp;&emsp;在列表之前和之后，都是要有换行的，不然列表会失效。另外在列表符号后要有空格这里直接使用代码换行，感觉比较好用，很明确。 这一段，我试验引用&emsp;&emsp;引用是可以嵌套的哦！ 这是单行引用。在处于引用范围内，回车换行不会真的换行的哦！这里我直接输代码，结束引用好像还是不行，确实是换行了，但还没有脱离引用的范围，我猜是要主动删除引用符，我试试 果然结束了哦，哈哈这里用了两个换行，果然是换了两行。这里我来实验一下嵌套的引用 在这里是最外层引用范围 呀的什么鬼，我在里面。好舒服！ 这里还是最外层的引用，不过马上就要结束了，再见，不散!(注意哦，我跟你说，要实现嵌套，需要在里面加一个换行，脱离内层引用。) 这里我要试验一下，代码块代码块内是可以使用一般的缩进的 12我在代码块里面在代码块里面感觉就是一般的书写没有别的什么特别的 这里是行内代码块 哈哈就是我 你看到了吗。（注意：需要和普通段落之间存在空行。）行内代码块的作用，我觉得，是可以展示一些有特效的东西，放进引用，就没有格式了。 我要试试，链接和图片了链接可以由两种形式生成：行内式和参考式。注意： 参考式链接和行内链接的显示效果是一样的。但是在编辑状态下的使用情况不一样。行内连接紧跟链接文字，可以在看到链接文字的同时清楚的知道链接地址，但是不便于多次重复利用。参考式链接我觉得可以放在文尾，用来展示引用。 使用 [](link &quot;Optional title&quot;) 表示行内链接。 这里是一个链接：链接文字放在框框里面 参考式文字 我要试试参考式开始文字参考式文字","categories":[{"name":"笔记","slug":"笔记","permalink":"http://sowhatxie.top/categories/笔记/"}],"tags":[{"name":"YAYA","slug":"YAYA","permalink":"http://sowhatxie.top/tags/YAYA/"},{"name":"Hexo","slug":"Hexo","permalink":"http://sowhatxie.top/tags/Hexo/"}]},{"title":"markdown测试","slug":"markdown 测试","date":"2017-05-13T07:17:10.000Z","updated":"2017-07-14T05:22:20.843Z","comments":true,"path":"2017/05/13/markdown 测试/","link":"","permalink":"http://sowhatxie.top/2017/05/13/markdown 测试/","excerpt":"","text":"markdown 测试设置代码块1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889package binaryheap;public class BinaryHeap &#123; private static final int DEFAULT_CAPACITY=10; public int currentSize; public int [] array; private void percolateDown(int hole)&#123; int child=0; //tmp值是那个传入的最初要下沉的值 int tmp=array[hole]; //这个for循环，结束之后,hole要不就是最后一个，要不就满足了堆，（子树）根节点最小的特性 for(;hole*2&lt;=currentSize;hole=child)&#123; child=hole*2; if(child!=currentSize &amp;&amp; (array[child+1]&lt;array[child]) ) child++; //如上的语句结束可以得到两个子节点中较小的那个 if(array[child]&lt;tmp)&#123; array[hole]=array[child]; &#125;else break; //如上判断结束hole到了最终的位置 &#125; array[hole]=tmp; &#125; private void buildHeap()&#123; //这里从currentSize/2这个位置（最后一个非叶节点）开始，直到根节点，不断下滤调整堆序。 for(int i= currentSize/2;i&gt;0;i--)&#123; percolateDown(i); &#125; &#125; public void enlarge(int newSize)&#123; int [] tmp=new int[newSize]; for(int i=1;i&lt;=currentSize;i++)&#123; tmp[i]=array[i]; &#125; array=tmp; &#125; public BinaryHeap(int [] data)&#123; //先依据传入的数组，建造无序堆，在调整成有序堆。 currentSize=data.length; array=new int[(currentSize+2)*11/10]; int i=1; for(int item : data) array[i++]=item; buildHeap(); &#125; public void makeEmpty()&#123; currentSize=0; &#125; public boolean isEmpty()&#123; return currentSize==0; &#125; public int min()&#123; if(isEmpty()) &#123; System.out.println(&quot;堆为空！返回-1&quot;); return -1; &#125; else&#123; return array[1]; &#125; &#125; public int deleteMin()&#123; if(isEmpty()) &#123; System.out.println(&quot;堆为空！返回-1&quot;); return -1; &#125; int lastmin =min(); array[1]=array[currentSize--]; percolateDown(1); return lastmin; &#125; public void insert(int data)&#123; //自动扩容 if(currentSize==array.length-1)&#123; enlarge(array.length*2+1); &#125; //上冒操作 int hole=++currentSize; for(;hole&gt;1 &amp;&amp; data &lt; array[hole/2];hole/=2) array[hole]=array[hole/2]; array[hole]=data; &#125; &#125; 下一个其实啥都目有！","categories":[{"name":"笔记","slug":"笔记","permalink":"http://sowhatxie.top/categories/笔记/"}],"tags":[{"name":"YAYA","slug":"YAYA","permalink":"http://sowhatxie.top/tags/YAYA/"},{"name":"Hexo","slug":"Hexo","permalink":"http://sowhatxie.top/tags/Hexo/"}]},{"title":"测试","slug":"测试","date":"2017-02-13T07:17:10.000Z","updated":"2017-07-14T04:48:33.128Z","comments":true,"path":"2017/02/13/测试/","link":"","permalink":"http://sowhatxie.top/2017/02/13/测试/","excerpt":"","text":"因为我们的博文都是用Markdown语言写的，所以首先，你需要一个好用的Markdown编辑器。其实好用的Markdown编辑器一大堆，这里就给大家推荐两个，如果你用的不习惯也可以换其它的。 本地编辑器：Haroopad，非常小众的一款Markdown编辑器，左边编辑右边实时预览效果，非常轻便； 在线编辑器：MaHua，也是比较小众的一款Markdown编辑器，但效果确实很棒，我的这篇博文就是用MaHua写的。 ‘’‘from django import template import mistune from pygments import highlight from pygments.lexers import get_lexer_by_name from pygments.formatters import HtmlFormatter register = template.Library() def block_code(text, lang, inlinestyles=False, linenos=False): if not lang: text = text.strip() return u’%s\\n’ % mistune.escape(text) try: lexer = get_lexer_by_name(lang, stripall=True) formatter = HtmlFormatter( noclasses=inlinestyles, linenos=linenos ) code = highlight(text, lexer, formatter) if linenos: return ‘%s\\n’ % code return code except: return ‘%s\\n’ % ( lang, mistune.escape(text) ) class HighlightMixin(object): def block_code(self, text, lang): # renderer has an options inlinestyles = self.options.get(‘inlinestyles’) linenos = self.options.get(‘linenos’) return block_code(text, lang, inlinestyles, linenos) class TocRenderer(HighlightMixin, mistune.Renderer): pass @register.filter def markdown_detail(value): renderer = TocRenderer(linenos=True, inlinestyles=False) mdp = mistune.Markdown(escape=True, renderer=renderer) return mdp(value) 作者：大阿拉伯人链接：http://www.jianshu.com/p/2909aed83dad來源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。’‘’","categories":[{"name":"笔记","slug":"笔记","permalink":"http://sowhatxie.top/categories/笔记/"}],"tags":[{"name":"YAYA","slug":"YAYA","permalink":"http://sowhatxie.top/tags/YAYA/"}]},{"title":"建站笔记","slug":"建站笔记","date":"2016-07-12T10:58:51.000Z","updated":"2017-07-14T03:36:47.097Z","comments":true,"path":"2016/07/12/建站笔记/","link":"","permalink":"http://sowhatxie.top/2016/07/12/建站笔记/","excerpt":"安装node.js准备命令： yum -y install gcc make gcc-c++ openssl-devel wget去node.js中文网下载linux 64位的安装文件 xxx.tar.xz解压缩文件 xz -d node-v8.1.3-linux-x64.tar.xz 再解压缩 tar -xvf node-v8.1.3-linux-x64.tar把文件直接移到 指定文件夹中 sudo mv node-v8.1.3-linux-x64 /usr/local配置环境变量 sudo vim /etc/profile 添加如下：export PATH=$PATH:/usr/local/nodejs/bin 生效 source /etc/profile查看是否配置成功：echo $PATH检查node.js是否配置成功 node -v npm -v","text":"安装node.js准备命令： yum -y install gcc make gcc-c++ openssl-devel wget去node.js中文网下载linux 64位的安装文件 xxx.tar.xz解压缩文件 xz -d node-v8.1.3-linux-x64.tar.xz 再解压缩 tar -xvf node-v8.1.3-linux-x64.tar把文件直接移到 指定文件夹中 sudo mv node-v8.1.3-linux-x64 /usr/local配置环境变量 sudo vim /etc/profile 添加如下：export PATH=$PATH:/usr/local/nodejs/bin 生效 source /etc/profile查看是否配置成功：echo $PATH检查node.js是否配置成功 node -v npm -v安装git:直接安装：sudo yum install git查看是否安装成功：git –version查看安装位置：which git配置git :git config –global user.name “LingJiangXie” git config –global user.email “xielj1994@outlook.com”查看配置列表：git config –list 在自己的git上新建一个 LingJiangXie.github.io（不能为空，否则没有节点）ssh 密药配置 参考http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001374385852170d9c7adf13c30429b9660d0eb689dd43a000 其他基本参考：http://www.cnblogs.com/wanghuaijun/p/7073296.html 部署服务时 出现问题参考：npm install hexo-deployer-git –save （此命令在新建的本地博客文件夹根目录执行）改了之后执行，然后再部署试试 修改，更换完主题 重新执行//生成静态文件hexo generate //部署服务hexo deploy 还可以参考这个： https://zhuanlan.zhihu.com/p/26625249 比较全","categories":[{"name":"笔记","slug":"笔记","permalink":"http://sowhatxie.top/categories/笔记/"}],"tags":[{"name":"YAYA","slug":"YAYA","permalink":"http://sowhatxie.top/tags/YAYA/"},{"name":"Hexo","slug":"Hexo","permalink":"http://sowhatxie.top/tags/Hexo/"}]}]}